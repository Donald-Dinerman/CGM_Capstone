---
title: "Mood/Glucose Capstone Project"
author: "Donald Dinerman (ddinerma)"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  pdf_document: default
  html_document: default
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T, warning = T, message = F)
```

# Research

```{r}
# https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5826763/#:~:text=Highlights,hour%20plasma%20glucose%20than%20men.&text=prevalent%20in%20women-,Type%201%20diabetes%20is%20the%20only%20common%20autoimmune%20disease%20not,incidence%20in%20boys%20after%20puberty.

# Highlights

# In response to an oral glucose tolerance test, women have lower fasting plasma glucose and higher 2-hour plasma glucose than men.

# Impaired fasting glucose is more prevalent in men while impaired glucose tolerance is more prevalent in women

# Type 1 diabetes is the only common autoimmune disease not characterized by a female predominance and exhibits an increased incidence in boys after puberty.
```


```{r}
#https://pubmed.ncbi.nlm.nih.gov/20182862/

# Abstract

# Aims/hypothesis: We aimed to examine whether sex differences in fasting plasma glucose (FPG), 2 h post-OGTT plasma glucose (2hPG) and HbA(1c) could be explained by differences in body size and/or body composition between men and women in a general non-diabetic Danish population. Moreover, we aimed to study to what degree the newly suggested high-risk HbA(1c) criteria overlapped with the current OGTT-based criteria of glucose intolerance.


# Methods: We used cross-sectional data from 6,006 non-diabetic men and women. HbA(1c) and FPG levels were measured and a 75 g OGTT was performed in all individuals. Height, weight and waist and hip circumferences were measured and BMI was calculated. Data were analysed in age-adjusted linear regression models.


# Results: Men had higher FPG and HbA(1c) levels than women, and women had higher 2hPG levels than men. Sex differences in 2hPG levels were explained by differences in height and FPG levels, but sex differences in FPG or HbA(1c) levels were not explained by anthropometric measures. Among individuals with HbA(1c) in the high-risk range (6.0-6.5%), 73% had normal glucose tolerance.


# Conclusions/interpretation: Sex differences in 2hPG levels after an OGTT may to some extent be a consequence of giving the same amount of glucose to individuals with different body size. In contrast, sex differences in FPG and HbA(1c) levels are likely to have a true physiological basis. In clinical practice, the HbA(1c) assay may be more convenient than the OGTT, but it is important to note that different populations are identified by the two methods.
```

# CGM Analytic Packages

```{r}
# https://github.com/RyanJ-Shao/CGMTSA
# Continuous Glucose Monitoring Time Series Data Analysis (CGMTSA) User Guide
# The R package Continuous Glucose Monitoring Time Series Data Analysis (CGMTSA) was developed to facilitate investigations that examine the continuous glucose monitoring (CGM) data as a time series. Accordingly, novel time series functions were introduced to (1) enable more accurate missing data imputation and outlier identification; (2) calculate recommended CGM metrics as well as key time series parameters; (3) plot interactive and three-dimensional graphs that allow direct visualizations of temporal CGM data and time series model optimization.
```

```{r}
# https://cran.r-project.org/web/packages/cgmanalysis/cgmanalysis.pdf
# Package ‘cgmanalysis’
# provides several different functions for cleaning and analyzing continuous glucose monitor data. 
# Currently it works with 'Dexcom', 'iPro 2', 'Diasend', 'Libre', or 'Carelink' data. 
```

# Data Intro
```{r}
library(tidyverse)
library(kableExtra)
library(lubridate)
library(cowplot)
library(mgcv)
library(mice)
library(broom.mixed) # tidy the lmer for pool()
library(lme4)
library(sjPlot)
```

```{r}
raw_data <- read.csv("complete_f_s_afterexclude.csv")
```

```{r}
head(raw_data)
```


```{r}
dim(raw_data)
unique(raw_data$respid) %>% length() # n Respondents (88)
```

```{r}
# Week number (1...7)
raw_data$datetime_ema %>%
  sub("T.*", "", .) %>%
  wday() %>%
  unique() %>%
  sort()
```

```{r}
#https://r-graph-gallery.com/web-line-chart-with-labels-at-end-of-line.html
# Later: Create custom theme for plots
```

# EDA

## Univariate

### Response
```{r}
resp_df <- raw_data %>%
  dplyr::select(respid, spring, tbh1female, datetime_ema, emanum0, 
                TBR_s, TBR_d, TBR_prop_1h, 
                TIR_prop_1h, TIR_prop_2h, TIR_d, TIR_s, 
                bg_mean_1h, bg_mean_s, bg_mean_d, 
                TAR_s)

# EDA BG
## BG Daily
bg_d_df <- resp_df %>%
  mutate(get_date = sub("T.*", "", datetime_ema)) %>%
  group_by(respid, get_date, spring) %>%
  summarise(bg_d_avg = mean(bg_mean_d))

na_resp <- bg_d_df[!complete.cases(bg_d_df), ] %>% 
  dplyr::select(respid)

bg_d_id_df <- bg_d_df %>%
  dplyr::filter(!(respid %in% na_resp$respid)) %>%
  group_by(respid, spring) %>%
  mutate(id=row_number())

total_avg_bg_d <- bg_d_id_df %>%
  group_by(id, spring) %>%
  summarise(tot_avg_bg_d = mean(bg_d_avg)) %>%
  dplyr::filter(id < 5)

p_spring <- bg_d_id_df %>%
  dplyr::filter(spring == 0) %>%
  ggplot() +
  geom_line(aes(x = id, y = bg_d_avg, col = as.factor(respid)), alpha =  0.2, size = 0.1, show.legend = F) +
  geom_line(data = dplyr::filter(total_avg_bg_d, spring == 0), aes(x = id, y = tot_avg_bg_d), col = "blue") +
  labs(x = "Day #", y = "Blood Glucose Level (mg/dL)", title = "Fall")

p_fall <- bg_d_id_df %>%
  dplyr::filter(spring == 1, id < 5) %>%
  ggplot() +
  geom_line(aes(x = id, y = bg_d_avg, col = as.factor(respid)), alpha =  0.2, size = 0.1, show.legend = F) +
  geom_line(data = dplyr::filter(total_avg_bg_d, spring == 1), aes(x = id, y = tot_avg_bg_d), col = "blue") +
  labs(x = "Day #", y = "Blood Glucose Level (mg/dL)", title = "Spring")

## BG Season
p_bg <- resp_df %>%
  group_by(respid, spring) %>%
  summarise(bg_s_avg = mean(bg_mean_s)) %>%
  ggplot() +
  geom_density(aes(x = bg_s_avg, col = as.factor(spring)), show.legend = F) +
  scale_colour_manual(values =c('0'='black','1'='red'), labels = c('Fall','Spring')) +
  geom_vline(xintercept = 70, linetype="dotdash") +
  geom_vline(xintercept = 180, linetype="dotdash") +
  geom_text(aes(x=80, label="\n70", y=0.013), colour="black", angle=0, size = 10/.pt, inherit.aes = FALSE) +
  geom_text(aes(x=190, label="\n180", y=0.013), colour="black", angle=0, size = 10/.pt, inherit.aes = FALSE) +
  labs(x = "Average Seasonal Blood Glucose (mg/dL)", y = "Density of Respondents", col = "Season")

## TAR Season
p_tar <- resp_df %>%
  group_by(respid, spring) %>%
  summarise(tar_s_avg = mean(TAR_s)) %>%
  ggplot() +
  geom_density(aes(x = tar_s_avg, col = as.factor(spring))) +
  scale_colour_manual(values =c('0'='black','1'='red'), labels = c('Fall','Spring')) +
  labs(x = "Proportion of Time Above Range", y = "", col = "Season")

# TBR Season
p_tbr <- resp_df %>%
  group_by(respid, spring) %>%
  summarise(bg_s_avg = mean(TBR_s)) %>%
  ggplot() +
  geom_density(aes(x = bg_s_avg, col = as.factor(spring)), show.legend = F) +
  scale_colour_manual(values =c('0'='black','1'='red'), labels = c('Fall','Spring')) +
  labs(x = "Proportion of Time Below Range", y = "Density of Respondents", col = "Season")

# TIR Season
p_tir <- resp_df %>%
  group_by(respid, spring) %>%
  summarise(bg_s_avg = mean(TIR_s)) %>%
  ggplot() +
  geom_density(aes(x = bg_s_avg, col = as.factor(spring)), show.legend = F) +
  scale_colour_manual(values =c('0'='black','1'='red'), labels = c('Fall','Spring')) +
  labs(x = "Proportion of Time in Range", y = "", col = "Season")

cowplot::plot_grid(p_spring, p_fall)

cowplot::plot_grid(p_bg, p_tar, p_tbr, p_tir)
```

```{r}
# Respondents freq
resp_freq <- raw_data %>%
  group_by(respid) %>%
  summarise(count = n())

ggplot(resp_freq) +
  geom_histogram(aes(x = count), col = "black", fill = "steelblue", binwidth = 5) +
  labs(x = "Data Entry Frequency", y = "# of Respondents")

# By season
resp_freq_szn <- raw_data %>%
  group_by(respid, spring) %>%
  summarise(count = n())

ggplot(resp_freq_szn) +
  geom_density(aes(x = count, col = as.factor(spring))) +
  scale_colour_manual(values =c('0'='black','1'='red'), labels = c('Fall','Spring')) +
  labs(x = "Data Entry Frequency", y = "Density of Respondents", col = "Season")
```


```{r}
# Number of woman/men/nb
## Fall
# Change gender to factor
resp_gen_df <- resp_df %>%
  mutate(
    gender = case_when(
      tbh1female == 0 ~ "Male",
      tbh1female == 1 ~ "Female",
      tbh1female == 2 ~ "Non Binary"),
    spring = ifelse(spring==0, "Fall", "Spring"), 
                    .keep = "unused")
  
resp_gen_df %>%
  group_by(respid, spring) %>%
  slice(1) %>%
  dplyr::filter(spring == "Fall") %>%
  ungroup() %>%
  count(gender) %>% 
  pivot_wider(names_from = gender, values_from = n) %>%
  kbl(caption = "Fall Gender Counts") %>%
  kable_styling()

## Spring
resp_gen_df %>%
  group_by(respid, spring) %>%
  slice(1) %>%
  dplyr::filter(spring == "Spring") %>%
  ungroup() %>%
  count(gender) %>% 
  pivot_wider(names_from = gender, values_from = n) %>%
  kbl(caption = "Spring Gender Counts") %>%
  kable_styling()
```

```{r}
# Graphs and Descriptive Statistics
# CGM for male/female
# Calculate like this to give ind. equal weights

resp_gen_df %>%
  group_by(respid, gender) %>%
  summarise(bg_s_avg = mean(bg_mean_s),
            bg_s_median = median(bg_mean_s)) %>%
  ungroup() %>%
  group_by(gender) %>%
  summarise('Mean' = mean(bg_s_avg),
            'Std Dev' = sd(bg_s_avg, na.rm = T), # average of indivdual sd
            'Median' = mean(bg_s_median)) %>% # average of indivdual median
  mutate_if(is.numeric, round, digits = 2) %>%
  filter(gender != "Non Binary") %>%
  rename(., Gender = gender) %>%
  kbl(caption = "Seasonal Blood Glucose by Gender") %>%
  kable_styling(full_width = F)
```

```{r}
# CGM Graphics colored/faceted by gender
 resp_gen_df %>%
  group_by(respid, spring, gender) %>%
  summarise(bg_s_avg = mean(bg_mean_s)) %>%
  filter(gender != "Non Binary") %>%
  ggplot() +
  geom_density(aes(x = bg_s_avg, col = gender)) +
  #geom_vline(xintercept = 70, linetype="dotdash") +
  #geom_vline(xintercept = 180, linetype="dotdash") +
  #geom_text(aes(x=80, label="\n70", y=0.013), colour="black", angle=0, size = 10/.pt, inherit.aes = FALSE) +
  #geom_text(aes(x=190, label="\n180", y=0.013), colour="black", angle=0, size = 10/.pt, inherit.aes = FALSE) +
  facet_grid(~spring) +
  labs(x = "Average Seasonal Blood Glucose (mg/dL)", y = "Density of Respondents", col = "Gender")
```

```{r}
# Investigate EDA of Time above range with threshold 180 and 250
resp_gen_df %>%
  group_by(respid, spring, gender) %>%
  summarise(bg_s_avg = mean(TAR_s))  %>%
  filter(gender != "Non Binary") %>%
  ggplot() +
  geom_density(aes(x = bg_s_avg, col = gender)) +
  facet_grid(~spring) +
  labs(x = "Time Above Range Proportion", y = "Density of Respondents", col = "Season")

resp_gen_df %>%
  group_by(respid, spring, gender) %>%
  summarise(bg_s_avg = mean(TAR_s))  %>%
  filter(gender != "Non Binary") %>%
  ggplot() +
  geom_boxplot(aes(x = bg_s_avg, y = gender)) +
  facet_grid(~spring) +
  labs(x = "Time Above Range Proportion", y = "Gender")
```

### Predictors

```{r}
# Highlighted Predictors
# c(Zperneg, Zperpos, zdmwell, zpa, zna, zfrconfl, zfrsupp)
# Some of these variables are not in the dataset
# Not clear what frconfl, frsupp is
# Issue missing data for many "important" predictors

x_df <- raw_data %>%
  dplyr::select(respid, spring, datetime_ema, emanum0, 
                frconfl, intstress, intannoy, intprob, 
                frsupp, intaccept, intfit, intenjoy, inttrueslf, intunderstd,
                dmwell)

summary(x_df)

x_mean <- x_df %>%
  mutate(spring = as.factor(spring)) %>%
  group_by(respid, spring) %>%
  summarise(m_con = mean(frconfl, na.rm = T), m_str = mean(intstress, na.rm = T), m_ann = mean(intannoy, na.rm = T), 
            m_prob = mean(intprob, na.rm = T), m_sup = mean(frsupp, na.rm = T), m_acc = mean(intaccept, na.rm = T), 
            m_fit = mean(intfit, na.rm = T), m_enj = mean(intenjoy, na.rm = T), m_tru = mean(inttrueslf, na.rm = T), 
            m_und = mean(intunderstd, na.rm = T), m_wel = mean(dmwell, na.rm = T))

x_dens_plot <- function(var){
  ggplot(x_mean) +
  geom_density(aes_string(x = var, col = "spring")) +
  scale_colour_manual(values =c('0'='black','1'='red'), labels = c('Fall','Spring')) +
  labs(x = var, y = "Density of Respondents", col = "Season")
}

for (i in colnames(x_mean)[3:ncol(x_mean)]){
  print(x_dens_plot(i))
}
```

## Bivariate

```{r}
#zanxiety, zhappiness, zdepr, zatease

mod_df <- raw_data %>%
  dplyr::select(respid, spring, tbh1female, datetime_ema, emanum0, 
                frconfl, intstress, intannoy, intprob, dmwell,
                frsupp, intaccept, intfit, intenjoy, inttrueslf, intunderstd,
                anxiety, happiness, depr, atease,
                TAR_s) %>%
  mutate(
    gender = case_when(
      tbh1female == 0 ~ "Male",
      tbh1female == 1 ~ "Female",
      tbh1female == 2 ~ "Non Binary"),
    spring = ifelse(spring==0, "Fall", "Spring"), 
                    .keep = "unused")

mod_sum_df <- mod_df %>%
  group_by(respid, spring, gender) %>%
  summarise(m_con = mean(frconfl, na.rm = T), m_str = mean(intstress, na.rm = T), m_ann = mean(intannoy, na.rm = T), 
            m_prob = mean(intprob, na.rm = T), m_sup = mean(frsupp, na.rm = T), m_acc = mean(intaccept, na.rm = T), 
            m_fit = mean(intfit, na.rm = T), m_enj = mean(intenjoy, na.rm = T), m_tru = mean(inttrueslf, na.rm = T), 
            m_und = mean(intunderstd, na.rm = T), m_wel = mean(dmwell, na.rm = T), m_anx = mean(anxiety, na.rm = T),
            m_hap = mean(happiness, na.rm = T), m_dep = mean(depr, na.rm = T), m_eas = mean(atease, na.rm = T),
            m_TAR_s = mean(TAR_s, na.rm = T))
```

```{r}
# Average emotions by gender
mod_sum_df %>%
  group_by(gender) %>%
  summarise(m_con = mean(m_con, na.rm = T), m_str = mean(m_str, na.rm = T), m_ann = mean(m_ann, na.rm = T), 
            m_prob = mean(m_prob, na.rm = T), m_sup = mean(m_sup, na.rm = T), m_acc = mean(m_acc, na.rm = T), 
            m_fit = mean(m_fit, na.rm = T), m_enj = mean(m_enj, na.rm = T), m_tru = mean(m_tru, na.rm = T), 
            m_und = mean(m_und, na.rm = T), m_wel = mean(m_wel, na.rm = T), m_anx = mean(m_anx, na.rm = T),
            m_hap = mean(m_hap, na.rm = T), m_dep = mean(m_dep, na.rm = T), m_eas = mean(m_eas, na.rm = T),
            m_TAR_s = mean(m_TAR_s, na.rm = T))
```

```{r}
# Distribution of emotion variables by gender
gen_mood_df <- mod_df %>%
  filter(gender != "Non Binary") %>%
  group_by(respid, gender) %>%
  summarise(m_con = mean(frconfl, na.rm = T), m_str = mean(intstress, na.rm = T), m_ann = mean(intannoy, na.rm = T), 
            m_prob = mean(intprob, na.rm = T), m_sup = mean(frsupp, na.rm = T), m_acc = mean(intaccept, na.rm = T), 
            m_fit = mean(intfit, na.rm = T), m_enj = mean(intenjoy, na.rm = T), m_tru = mean(inttrueslf, na.rm = T), 
            m_und = mean(intunderstd, na.rm = T), m_wel = mean(dmwell, na.rm = T), m_anx = mean(anxiety, na.rm = T),
            m_hap = mean(happiness, na.rm = T), m_dep = mean(depr, na.rm = T), m_eas = mean(atease, na.rm = T))

gen_mood_plot <- function(var){
  ggplot(gen_mood_df) +
  geom_density(aes_string(x = var, col = "gender")) +
  labs(x = var, y = "Density of Respondents", col = "Gender")
}

for (i in colnames(gen_mood_df)[3:ncol(gen_mood_df)]){
  print(gen_mood_plot(i))
}
```

```{r}
t_test_res <- lapply(gen_mood_df[-c(1,2)], function(x) t.test(x ~ gen_mood_df$gender))
t_test_res
```

```{r, warning=F}
# sig diff var: m_acc, m_wel, m_hap, m_eas
p1_gen <- ggplot(gen_mood_df) +
  geom_density(aes_string(x = "m_acc", col = "gender"), show.legend = F) +
  labs(x = "Acceptance Rating", y = "Density of Respondents", col = "Gender") +
  theme_bw()

p2_gen <- ggplot(gen_mood_df) +
  geom_density(aes_string(x = "m_wel", col = "gender"), show.legend = F) +
  labs(x = "Self Care Rating", y = "Density of Respondents", col = "Gender") +
  theme_bw()

p3_gen <- ggplot(gen_mood_df) +
  geom_density(aes_string(x = "m_hap", col = "gender"), show.legend = T) +
  labs(x = "Happiness Rating", y = "", col = "Gender") +
  theme_bw()

p4_gen <- ggplot(gen_mood_df) +
  geom_density(aes_string(x = "m_eas", col = "gender"), show.legend = F) +
  labs(x = "At Ease Rating", y = "Density of Respondents", col = "Gender") +
  theme_bw()

cowplot::plot_grid(p2_gen, p3_gen, p4_gen)
```


```{r}
scatter_plot <- function(var){
  ggplot(mod_sum_df, aes_string(x = var, y = "m_TAR_s")) +
  geom_point(alpha = 0.2) +
  geom_smooth(se=F) + # loess
  labs(x = var, y = "Time Above Range (Seasonal)")
}

for (i in colnames(mod_sum_df)[4:ncol(mod_sum_df)-1]){
  print(scatter_plot(i))
}
```

```{r}
#Significant scatterplot for client prez
ggplot(mod_sum_df, aes_string(x = "m_wel", y = "m_TAR_s")) +
  geom_point(alpha = 0.2) +
  geom_smooth(se=F) + # loess
  labs(x = "Average Self Care Rating", y = "Time Above Range (Seasonal)", 
       title = "Better Self Care is Related with Less Time Above Range") +
  theme_bw()
```


# Modeling

## Aggregated

```{r}
# Try GAM model with seasonal level data
# Response: TAR seasonal
# Predictors: ref to predictor list

#Note: The F statistic explains predictors impact on output response

mod_sum_df_f <- filter(mod_sum_df, gender != "Non Binary")

gam_model <- gam(m_TAR_s ~ s(m_con) + s(m_sup) + s(m_wel) + s(m_anx) + s(m_hap) + s(m_dep) + s(m_eas) + as.factor(gender),
                 data = mod_sum_df_f,
                 method = "REML")

summary(gam_model) # Investigate relationships with scatterplots

par(mfrow = c(3,3))
plot(gam_model)
```


```{r}
# Mixed Model
# Multilevel model
# Random Intercept at individual level
# Random slopes for moods at gender

mixed_model <- lmer(m_TAR_s ~ m_con + m_sup + m_wel + as.factor(gender) + m_eas + m_dep + m_hap + m_anx + (1 | respid),
                    data = mod_sum_df_f)

summary(mixed_model)
# supp and con are funcitions of other var, client wants these
```

```{r}
# Granular Modeling with lag variable of response
# For time series modeling include lagged version of response as covariate
# Also include the emotion/mood variables and gender as covariate
```

```{r}
# Linear Mixed Model
# Residual analysis to check model assumptions
  # Correlated errors when using lag (AR(1) autocorrelated errors)
# mood and social interaction variables as a fixed effect
# make time 1...8 (linear effect of time)
# 1. No lag
# 2. With lag, compare models' n
# 3. Impute missing values of y (so the lag model has higher n), (can average using linear interpretation)
  # If we have 1 and 4, 2 and 3 missing, draw line between 1 and 4 and map the corresponding y values for 2 and 3
  # later can look into multiple imputation (MICE package in R)
```

## Granular

Model Specifications

$$
\begin{aligned}

y_{itds} =& \; \alpha_{i} + \beta^{time}x^{time}_{t} + \beta^{week} x^{week}_{d} + \beta^{season} x^{season}_{s} + \beta^{gender}x^{gender}_{i} + 
\beta^{mood} x^{mood}_{itds} + \beta^{positive \:interactions} x^{positive \:interactions}_{itds} +

\\ &

\beta^{negative \:interactions} x^{negative \:interactions}_{itds} + \beta^{self care}x^{self care}_{itds} + \beta^{eat}x^{eat}_{itds} + \beta^{exercise}x^{exercise}_{itds} + \epsilon_{itds}

\end{aligned}
$$

$$
\begin{aligned}

y_{itds} =& \; \alpha_{i} + \beta^{time}x^{time}_{t} + \beta^{week} x^{week}_{d} + \beta^{season} x^{season}_{s} + \beta^{gender}x^{gender}_{i} + 
\beta^{mood} x^{mood}_{itds} + \beta^{positive \:interactions} x^{positive \:interactions}_{itds} +

\\ &

\beta^{negative \:interactions} x^{negative \:interactions}_{itds} + \beta^{self care}x^{self care}_{itds} + \beta^{eat}x^{eat}_{itds} + \beta^{exercise}x^{exercise}_{itds} + \epsilon_{itds}

\end{aligned}
$$


$$
\begin{aligned}

y_{itds} =& \; \alpha_{i} + \beta^{lag} y_{i(t-1)ds} + \beta^{time}x^{time}_{t} + \beta^{week} x^{week}_{d} + \beta^{season} x^{season}_{s} + \beta^{gender}x^{gender}_{i} +  \beta^{mood} x^{mood}_{itds} +  \beta^{positive \:interactions} x^{positive \:interactions}_{itds} +

\\ &

\beta^{negative \:interactions} x^{negative \:interactions}_{itds} + \beta^{self care}x^{self care}_{itds} + \beta^{eat}x^{eat}_{itds} + \beta^{exercise}x^{exercise}_{itds} + \epsilon_{itds}

\end{aligned}
$$

### 1 Hour TAR
```{r}
head(raw_data)
```

```{r}
# Measure Time difference since 7 am (Anytime before 7 am is automatically 0)
# and 
# Early morning high bg level (boolean)
# https://www.webmd.com/diabetes/morning-high-blood-sugar-levels (2am-8am)

time_diff <- function(bool = F) {

  ## Time difference numeric
  my_vec <- ymd_hms(raw_data$datetime_ema)

  # Extract the hms values from the ymd_hms values
  my_hms <- hms(format(my_vec, "%H:%M:%S"))

  # Convert HMS time to 24-hour format
  my_decimal_time <- (as.numeric(my_hms) / (60 * 60))

  # Time Diff to 7 am
  time_diff <- my_decimal_time - 7

  # Cap st (Anytime before 7 am is automatically 0)
  time_diff_mod <- ifelse(time_diff < 0, 0, time_diff)
  
  bool_val <- my_decimal_time >= 2 & my_decimal_time <= 8
  
  ifelse(bool == T, return(bool_val), return(time_diff_mod))
}
```


```{r}
#Time/EMA
# Change to time since 7 am (or other early time period)
time_count <- c()
time_count[1] <- 1
for (i in 1:(nrow(raw_data)-1)) {
  if (raw_data$day_ema[i+1] == raw_data$day_ema[i]) {
    time_count[i+1] <- time_count[i]+1
  }
  else{
    time_count[i+1] <- 1
  }
}

# Identify weekday/end
weekday_func <- function(x){
  num <- x %>% sub("T.*", "", .) %>% wday()
  ans <- ifelse(num < 6, "Weekday", "Weekend")
  return(ans)
}

# m_TAR_s ~ m_con + m_sup + m_wel + as.factor(gender) + m_eas + m_dep + m_hap + m_anx + (1 | respid)
gran_df <- raw_data %>%
  dplyr::select(TAR_prop_1h, respid, spring, tbh1female, datetime_ema, 
                negative_interaction = frconfl, positive_interaction = frsupp, self_care = dmwell, 
                anxiety, happiness, depression = depr, atease, eat, exercise = exer
                ) %>%
  mutate(
    respid = as.factor(respid),
    time = time_count,
    week = weekday_func(datetime_ema),
    spring = ifelse(spring==0, "Fall", "Spring"),
    gender = case_when(
      tbh1female == 0 ~ "Male",
      tbh1female == 1 ~ "Female",
      tbh1female == 2 ~ "Non Binary"),
    .keep = "unused", .after = TAR_prop_1h) %>%
  filter(gender != "Non Binary")

# Missing Values
gran_df %>%
  select(everything()) %>%  # replace to your needs
  summarise_all(funs(sum(is.na(.))))
```

```{r}
# Drop all NA
gran_mod <- lmer(TAR_prop_1h ~ (1 | respid) + time + week + spring + gender + positive_interaction + negative_interaction + 
                   self_care + anxiety + happiness + depression + atease + eat + exercise,
                    data = drop_na(gran_df))

summary(gran_mod)
```

```{r}
# Imputation: With TAR_prop_1h (y) 

# https://www.analyticsvidhya.com/blog/2016/03/tutorial-powerful-packages-imputing-missing-values/
# Predictive Mean Matching: https://stefvanbuuren.name/fimd/sec-pmm.html
# Pooling with MICE: https://www.gerkovink.com/miceVignettes/Convergence_pooling/Convergence_and_pooling.html

impute_list <- make.blocks(c("TAR_prop_1h"))

imputed_Data <- mice(gran_df, m=5, maxit = 50, method = 'pmm', seed = 500, blocks = impute_list)
summary(imputed_Data)
```

```{r}
# Imputation Modeling
#get complete data (1st out of 5)
completeData <- complete(imputed_Data,1)

mod_1hr <- lmer(TAR_prop_1h ~ (1 | respid) + time + week + spring + gender + positive_interaction + negative_interaction + 
                    self_care + anxiety + happiness + depression + atease + eat + exercise,
                    data = completeData)

summary(mod_1hr)

# This is for when I have more time to run the imputation and can pool the parameters (Takes so long)
# build predictive model
fit_1hr <- with(data = imputed_Data, 
            exp = lmer(TAR_prop_1h ~ (1 | respid) + time + week + spring + gender + positive_interaction + negative_interaction + 
                         self_care + anxiety + happiness + depression + atease + eat + exercise))

# combine results of all 5 models
combine_1hr <- pool(fit_1hr)
summary(combine_1hr)

# Residuals
mod_1hr_r <- residuals(mod_1hr)
par(mfrow=c(2,2))
plot(mod_1hr_r)
qqnorm(mod_1hr_r)
qqline(mod_1hr_r)

hist(mod_1hr_r)

astsa::acf2(mod_1hr_r)
```

```{r}
# Mixed model with lag
# Caution: https://statisticalhorizons.com/lagged-dependent-variables/
lagged_df <- completeData %>%
  mutate(TAR_1hr_lagged = lag(TAR_prop_1h, n = 1, default = NA), .before = week) %>%
  drop_na(TAR_1hr_lagged)

lag_1hr_mod <- lmer(TAR_prop_1h ~ (1 | respid) + TAR_1hr_lagged + time + week + spring + gender + positive_interaction + negative_interaction + 
                  self_care + anxiety + happiness + depression + atease + eat + exercise,
                data = lagged_df)

summary(lag_1hr_mod)

# Residuals
lag_1hr_r <- residuals(lag_1hr_mod)
par(mfrow=c(2,2))
plot(lag_1hr_r)
qqnorm(lag_1hr_r)
qqline(lag_1hr_r)

hist(lag_1hr_r, main = "Residual Distribution", xlab = "Residuals")

astsa::acf2(lag_1hr_r)
```

### 2 Hour TAR

```{r}
# Set Data
gran_2hr_df <- raw_data %>%
  dplyr::select(TAR_prop_2h, respid, spring, tbh1female, datetime_ema, 
                negative_interaction = frconfl, positive_interaction = frsupp, self_care = dmwell, 
                anxiety, happiness, depression = depr, atease, eat, exercise = exer
                ) %>%
  mutate(
    respid = as.factor(respid),
    time = time_count,
    week = weekday_func(datetime_ema),
    spring = ifelse(spring==0, "Fall", "Spring"),
    gender = case_when(
      tbh1female == 0 ~ "Male",
      tbh1female == 1 ~ "Female",
      tbh1female == 2 ~ "Non Binary"),
    .keep = "unused", .after = TAR_prop_2h) %>%
  filter(gender != "Non Binary")

# Missing Values
gran_2hr_df %>%
  select(everything()) %>%  # replace to your needs
  summarise_all(funs(sum(is.na(.))))

# Imputation
impute_list_2hr <- make.blocks(c("TAR_prop_2h"))

imputed_Data_2hr <- mice(gran_2hr_df, m=5, maxit = 50, method = 'pmm', seed = 500, blocks = impute_list_2hr)

completeData_2hr <- complete(imputed_Data_2hr,1)
```

```{r}
# Imputation Modeling
mod_2hr <- lmer(TAR_prop_2h ~ (1 | respid) + time + week + spring + gender + positive_interaction + negative_interaction + 
                    self_care + anxiety + happiness + depression + atease + eat + exercise,
                    data = completeData_2hr)

summary(mod_2hr)

# This is for when I have more time to run the imputation and can pool the parameters (Takes so long)
# build predictive model
fit_2hr <- with(data = imputed_Data_2hr, 
            exp = lmer(TAR_prop_2h ~ (1 | respid) + time + week + spring + gender + positive_interaction + negative_interaction + 
                         self_care + anxiety + happiness + depression + atease + eat + exercise))

# combine results of all 5 models
combine_2hr <- pool(fit_2hr)
summary(combine_2hr)

# Residuals
mod_2hr_r <- residuals(mod_2hr)

par(mfrow=c(2,2))
plot(mod_2hr_r)
qqnorm(mod_2hr_r)
qqline(mod_2hr_r)

hist(mod_2hr_r)

astsa::acf2(mod_2hr_r)
```

```{r}
# Mixed model with lag
# Caution: https://statisticalhorizons.com/lagged-dependent-variables/
lagged_2hr_df <- completeData_2hr %>%
  mutate(TAR_2hr_lagged = lag(TAR_prop_2h, n = 1, default = NA), .before = week) %>%
  drop_na(TAR_2hr_lagged)

lag_2hr_mod <- lmer(TAR_prop_2h ~ (1 | respid) + TAR_2hr_lagged + time + week + spring + gender + positive_interaction + negative_interaction + 
                  self_care + anxiety + happiness + depression + atease + eat + exercise,
                data = lagged_2hr_df)

summary(lag_2hr_mod)

# Residuals
lag_2hr_r <- residuals(lag_2hr_mod)
par(mfrow=c(2,2))
plot(lag_2hr_r)
qqnorm(lag_2hr_r)
qqline(lag_2hr_r)

hist(lag_2hr_r)

astsa::acf2(lag_2hr_r)
```

```{r}
# Before and After Imputation (Non-ts)
tab_model(gran_mod, mod_1hr, show.ci = F)

# Imputed Y Models
# TAR 1 hr (w/o lag, w lag)
tab_model(mod_1hr, lag_1hr_mod, show.ci = F)

# TAR 2 hr (w/o lag, w lag)
tab_model(mod_2hr, lag_2hr_mod, show.ci = F)
```

## Additional Misc. EDA

```{r}
# Show histograms for prez
hist_1 <- ggplot(lagged_df) +
  geom_histogram(aes(x = depression), col = "black", fill = "steelblue") +
  theme_bw() +
  labs(x = "Depression", y = "Count")

hist_2 <- ggplot(lagged_df) +
  geom_histogram(aes(x = anxiety), col = "black", fill = "steelblue") +
  theme_bw() +
  labs(x = "Anxiety", y = "")

hist_3 <- ggplot(lagged_df) +
  geom_histogram(aes(x = happiness), col = "black", fill = "steelblue") +
  theme_bw() +
  labs(x = "Happiness", y = "Count")

hist_4 <- ggplot(lagged_df) +
  geom_histogram(aes(x = atease), col = "black", fill = "steelblue") +
  theme_bw() +
  labs(x = "At Ease", y = "")

title <- ggdraw() + draw_label("Mood Histograms", fontface='bold')

p <- cowplot::plot_grid(hist_1, hist_2, hist_3, hist_4)

cowplot::plot_grid(title, p, ncol=1, rel_heights=c(0.1, 1)) # rel_heights values control title margins
```

```{r}
# Histogram of Survey Times
my_vec <- ymd_hms(raw_data$datetime_ema)

# Extract the hms values from the ymd_hms values
my_hms <- hms(format(my_vec, "%H:%M:%S"))

# Convert HMS time to 24-hour format
my_decimal_time <- (as.numeric(my_hms) / (60 * 60))

as.data.frame(my_decimal_time) %>%
  ggplot() +
  geom_histogram(aes(x=my_decimal_time), bins = 24, col = "Black", fill = "Steelblue") +
  labs(x = "Time (Hours)", y = "# Responses", title = "Time Distribution of Survey Responses") +
  theme_bw()
```


*Note: Final Model should likely be pooled result when using stochastic model-based imputation*

*Questions:*
1. What to select as response (1hr or 2hr)?
2. Should we dichotomize the depression variable?
3. Should we do imputations for covariates as well? Yes, for final model

*Note:*
1. We changed the time variable so that it is either a boolean (between 2 and 8 am) or numeric difference since 7am (min capped at zero)
  a. Yet to implement in model, currently time represents daily survey count

```{r}
# Look at changing time t of interaction/mood variables
  # Check cross-correlation of TAR prop and moods
# Look at adding and checking results for different feature engineering of time (they prefer time since 7 am)
# Look into accounting for autocorrelated errors in the model (like GLS but for mixed model)
```

